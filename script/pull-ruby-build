#! /usr/bin/env bash

# This is intended to help automate the process of pull changes down from
# ruby-build upstream. It uses custom 'rbtags' ref namespace for ruby-build's
# tags (that way ruby-builds tags don't pollute node-build's tags). It re-uses
# a staging branch where ruby-build's tags will be merged into. It finds only
# the very "next" un-merged ruby-build tag; diffs against that and merges it.
# Then removes the ruby-build defs and known scripts that don't apply to
# node-build. Should leave the working copy in a MERGING state.

set -euo pipefail

trace() { (set -x; "$@"); }

rbtags='refs/rbtags/'
ruby_build='https://github.com/rbenv/ruby-build.git'

clean_branch() {
  br=${1:-pull-ruby-build}
  start=${2:-origin/main}

  git fetch --no-tags $ruby_build "refs/tags/*:$rbtags*"
  git checkout --no-track -b "$br" "$start" ||
  [ "$br" = "$(git rev-parse --abbrev-ref HEAD)" ]

  # TODO: check clean WC here
}

rbtag(){
  merged=$1
  main=${2:-HEAD}
  case $merged in
  --merged) only='tail' ;;
  --no-merged) only='head' ;;
  *) exit 1 ;;
  esac

  trace git for-each-ref $rbtags \
  --format '%(refname)' --sort=refname "$merged" "$main" | $only -1
}

next_unmerged_rbtag(){
  {
    upstream=${1:-ruby-build/master}
    main=${2:-HEAD}

    trace git describe --all --exact-match \
      "$(trace git merge-base "$main" "$upstream")"

    vlast=$(rbtag --merged)
    vnext=$(rbtag --no-merged)

    trace git diff "${vlast:?}"..."${vnext:?}" \
      -- ':!share/' ':!script/*ruby*'
  } >&2

  echo "$vnext"
}

merge(){
  ref=${1:?}

  # FIXME: find better way to handle the expected errexit
  # TODO: improve commit message
  git merge --no-commit --quiet "$ref" || true

  # TODO: this stuff should be a custom merge-driver
  git rm -rf share/ruby-build
  git rm -rf script/update-*ruby
}

# clean_branch ruby-build-update origin/main

merge "$(next_unmerged_rbtag ruby-build/master)"
